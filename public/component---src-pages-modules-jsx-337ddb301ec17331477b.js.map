{"version":3,"sources":["webpack:///component---src-pages-modules-jsx-337ddb301ec17331477b.js","webpack:///./~/mobx-react/index.js","webpack:///./src/components/EmptyPage.jsx","webpack:///./src/pages/modules.jsx"],"names":["webpackJsonp","34","module","exports","__webpack_require__","global","factory","this","mobx","react","reactDom","createChainableTypeChecker","validate","checkType","isRequired","props","propName","componentName","location","propFullName","_len","arguments","length","rest","Array","_key","untracked","actual","Error","apply","undefined","concat","chainedCheckType","bind","isSymbol","propType","propValue","Symbol","getPropType","_typeof","isArray","RegExp","getPreciseType","Date","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","isObservableArray","isObservableObject","isObservableMap","preciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","_len2","_key2","error","i","isStateless","component","prototype","render","createStoreInjector","grabStoresFn","injectNames","_class","_temp2","displayName","name","constructor","Injector","_Component","_ref","_temp","_this","_ret","classCallCheck","args","possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","storeRef","instance","wrappedInstance","inherits","createClass","key","value","newProps","hasOwnProperty","additionalProps","context","mobxStores","ref","createElement","Component","hoistNonReactStatics","wrappedComponent","defineProperties","proxiedInjectorProps","grabStoresByName","storeNames","baseStores","nextProps","forEach","storeName","inject","componentClass","injected","isMobxInjector","observer","join","findDOMNode$2","findDOMNode","e","reportRendering","node","componentByNodeRegistery","set","renderReporter","emit","event","renderTime","__$mobRenderEnd","__$mobRenderStart","totalTime","now","trackComponents","WeakMap","isDevtoolsEnabled","useStaticRendering","isUsingStaticRendering","patch","target","funcName","runMixinFirst","base","mixinFunc","reactiveMixin","f","isObjectShallowModified","prev","next","keys","arg1","arg2","warnedAboutObserverInjectDeprecation","console","warn","isReactClass","isPrototypeOf","contextTypes","propTypes","defaultProps","mixinLifecycleEvents","isMobXReactObserver","shouldComponentUpdate","unstable_batchedUpdates$1","iterator","obj","AwaitValue","AsyncGenerator","gen","send","arg","Promise","resolve","reject","request","back","front","resume","result","then","settle","done","err","type","_invoke","return","asyncIterator","throw","wrap","fn","await","Constructor","TypeError","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","subClass","superClass","create","setPrototypeOf","self","ReferenceError","EventEmitter","listeners","cb","push","index","indexOf","splice","data","REACT_STATICS","childContextTypes","getDefaultProps","mixins","KNOWN_STATICS","caller","callee","arity","defineProperty$1","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","objectPrototype","targetComponent","sourceComponent","blacklist","inheritedComponent","observableArray","observableArrayOf","observableMap","observableObject","arrayOrObservableArray","arrayOrObservableArrayOf","objectOrObservableObject","freeze","injectorContextTypes","seal","get","_","errorsReporter","componentWillMount","makePropertyObservableReference","valueHolder","atom","Atom","reportObserved","v","isForcingUpdate","skipRender","reportChanged","initialName","rootNodeID","_reactInternalInstance","_rootNodeID","baseRender","reaction","isRenderingPending","initialRender","Reaction","componentWillReact","__$mobxIsUnmounted","hasError","forceUpdate","dispose","reactComponent","reactiveRender","$mobx","exception","rendering","track","extras","allowStateChanges","componentWillUnmount","delete","componentDidMount","componentDidUpdate","nextState","state","Observer","children","specialReactKeys","Provider","Children","only","stores","suppressChangedStoreWarning","unstable_batchedUpdates","setReactionScheduler","onError","on","__MOBX_DEVTOOLS_GLOBAL_HOOK__","mobx$1","spy","mobxReact","injectMobxReact","PropTypes","103","_interopRequireDefault","__esModule","default","_taggedTemplateLiteralLoose","strings","raw","_classCallCheck","_possibleConstructorReturn","_inherits","_templateObject","_react","_react2","_propTypes","_propTypes2","_styledComponents","_styledComponents2","_styles","_styles2","EmptyPage","_React$Component","className","title","message","div","color","string","297","_mobxReact","_Page","_Page2","_AppState","_AppState2","_TypeState","_TypeState2","_objectType","_CreateType","_CreateType2","_EmptyPage","_EmptyPage2","Modules","getModuleTypes","moduleTypes","types","orderedUserMadeTypeList","id","child","instanceOf"],"mappings":"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","file":"component---src-pages-modules-jsx-337ddb301ec17331477b.js","sourcesContent":["webpackJsonp([29644012231294],{\n\n/***/ 34:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? factory(exports, __webpack_require__(35), __webpack_require__(2), __webpack_require__(19)) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports', 'mobx', 'react', 'react-dom'], factory) :\n\t\t(factory((global.mobxReact = {}),global.mobx,global.React,global.ReactDOM));\n\t}(this, (function (exports,mobx,react,reactDom) { 'use strict';\n\t\n\t// These functions can be stubbed out in specific environments\n\tvar unstable_batchedUpdates$1 = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\t\n\t\n\t\n\t\n\t\n\tvar asyncGenerator = function () {\n\t  function AwaitValue(value) {\n\t    this.value = value;\n\t  }\n\t\n\t  function AsyncGenerator(gen) {\n\t    var front, back;\n\t\n\t    function send(key, arg) {\n\t      return new Promise(function (resolve, reject) {\n\t        var request = {\n\t          key: key,\n\t          arg: arg,\n\t          resolve: resolve,\n\t          reject: reject,\n\t          next: null\n\t        };\n\t\n\t        if (back) {\n\t          back = back.next = request;\n\t        } else {\n\t          front = back = request;\n\t          resume(key, arg);\n\t        }\n\t      });\n\t    }\n\t\n\t    function resume(key, arg) {\n\t      try {\n\t        var result = gen[key](arg);\n\t        var value = result.value;\n\t\n\t        if (value instanceof AwaitValue) {\n\t          Promise.resolve(value.value).then(function (arg) {\n\t            resume(\"next\", arg);\n\t          }, function (arg) {\n\t            resume(\"throw\", arg);\n\t          });\n\t        } else {\n\t          settle(result.done ? \"return\" : \"normal\", result.value);\n\t        }\n\t      } catch (err) {\n\t        settle(\"throw\", err);\n\t      }\n\t    }\n\t\n\t    function settle(type, value) {\n\t      switch (type) {\n\t        case \"return\":\n\t          front.resolve({\n\t            value: value,\n\t            done: true\n\t          });\n\t          break;\n\t\n\t        case \"throw\":\n\t          front.reject(value);\n\t          break;\n\t\n\t        default:\n\t          front.resolve({\n\t            value: value,\n\t            done: false\n\t          });\n\t          break;\n\t      }\n\t\n\t      front = front.next;\n\t\n\t      if (front) {\n\t        resume(front.key, front.arg);\n\t      } else {\n\t        back = null;\n\t      }\n\t    }\n\t\n\t    this._invoke = send;\n\t\n\t    if (typeof gen.return !== \"function\") {\n\t      this.return = undefined;\n\t    }\n\t  }\n\t\n\t  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n\t    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n\t      return this;\n\t    };\n\t  }\n\t\n\t  AsyncGenerator.prototype.next = function (arg) {\n\t    return this._invoke(\"next\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.throw = function (arg) {\n\t    return this._invoke(\"throw\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.return = function (arg) {\n\t    return this._invoke(\"return\", arg);\n\t  };\n\t\n\t  return {\n\t    wrap: function (fn) {\n\t      return function () {\n\t        return new AsyncGenerator(fn.apply(this, arguments));\n\t      };\n\t    },\n\t    await: function (value) {\n\t      return new AwaitValue(value);\n\t    }\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\t\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar possibleConstructorReturn = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\t\n\tvar EventEmitter = function () {\n\t    function EventEmitter() {\n\t        classCallCheck(this, EventEmitter);\n\t        this.listeners = [];\n\t    }\n\t\n\t    createClass(EventEmitter, [{\n\t        key: \"on\",\n\t        value: function on(cb) {\n\t            var _this = this;\n\t\n\t            this.listeners.push(cb);\n\t            return function () {\n\t                var index = _this.listeners.indexOf(cb);\n\t                if (index !== -1) _this.listeners.splice(index, 1);\n\t            };\n\t        }\n\t    }, {\n\t        key: \"emit\",\n\t        value: function emit(data) {\n\t            this.listeners.forEach(function (fn) {\n\t                return fn(data);\n\t            });\n\t        }\n\t    }]);\n\t    return EventEmitter;\n\t}();\n\t\n\t/**\n\t * Copyright 2015, Yahoo! Inc.\n\t * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n\t */\n\t'use strict';\n\t\n\tvar REACT_STATICS = {\n\t    childContextTypes: true,\n\t    contextTypes: true,\n\t    defaultProps: true,\n\t    displayName: true,\n\t    getDefaultProps: true,\n\t    mixins: true,\n\t    propTypes: true,\n\t    type: true\n\t};\n\t\n\tvar KNOWN_STATICS = {\n\t  name: true,\n\t  length: true,\n\t  prototype: true,\n\t  caller: true,\n\t  callee: true,\n\t  arguments: true,\n\t  arity: true\n\t};\n\t\n\tvar defineProperty$1 = Object.defineProperty;\n\tvar getOwnPropertyNames = Object.getOwnPropertyNames;\n\tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\tvar getPrototypeOf = Object.getPrototypeOf;\n\tvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\t\n\tvar hoistNonReactStatics = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n\t    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\t\n\t        if (objectPrototype) {\n\t            var inheritedComponent = getPrototypeOf(sourceComponent);\n\t            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n\t                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n\t            }\n\t        }\n\t\n\t        var keys = getOwnPropertyNames(sourceComponent);\n\t\n\t        if (getOwnPropertySymbols) {\n\t            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n\t        }\n\t\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n\t                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\t                try { // Avoid failures from read-only properties\n\t                    defineProperty$1(targetComponent, key, descriptor);\n\t                } catch (e) {}\n\t            }\n\t        }\n\t\n\t        return targetComponent;\n\t    }\n\t\n\t    return targetComponent;\n\t};\n\t\n\t// Copied from React.PropTypes\n\tfunction createChainableTypeChecker(validate) {\n\t    function checkType(isRequired, props, propName, componentName, location, propFullName) {\n\t        for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n\t            rest[_key - 6] = arguments[_key];\n\t        }\n\t\n\t        return mobx.untracked(function () {\n\t            componentName = componentName || \"<<anonymous>>\";\n\t            propFullName = propFullName || propName;\n\t            if (props[propName] == null) {\n\t                if (isRequired) {\n\t                    var actual = props[propName] === null ? \"null\" : \"undefined\";\n\t                    return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n\t                }\n\t                return null;\n\t            } else {\n\t                return validate.apply(undefined, [props, propName, componentName, location, propFullName].concat(rest));\n\t            }\n\t        });\n\t    }\n\t\n\t    var chainedCheckType = checkType.bind(null, false);\n\t    chainedCheckType.isRequired = checkType.bind(null, true);\n\t    return chainedCheckType;\n\t}\n\t\n\t// Copied from React.PropTypes\n\tfunction isSymbol(propType, propValue) {\n\t    // Native Symbol.\n\t    if (propType === \"symbol\") {\n\t        return true;\n\t    }\n\t\n\t    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n\t    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n\t        return true;\n\t    }\n\t\n\t    // Fallback for non-spec compliant Symbols which are polyfilled.\n\t    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\t// Copied from React.PropTypes\n\tfunction getPropType(propValue) {\n\t    var propType = typeof propValue === \"undefined\" ? \"undefined\" : _typeof(propValue);\n\t    if (Array.isArray(propValue)) {\n\t        return \"array\";\n\t    }\n\t    if (propValue instanceof RegExp) {\n\t        // Old webkits (at least until Android 4.0) return 'function' rather than\n\t        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n\t        // passes PropTypes.object.\n\t        return \"object\";\n\t    }\n\t    if (isSymbol(propType, propValue)) {\n\t        return \"symbol\";\n\t    }\n\t    return propType;\n\t}\n\t\n\t// This handles more types than `getPropType`. Only used for error messages.\n\t// Copied from React.PropTypes\n\tfunction getPreciseType(propValue) {\n\t    var propType = getPropType(propValue);\n\t    if (propType === \"object\") {\n\t        if (propValue instanceof Date) {\n\t            return \"date\";\n\t        } else if (propValue instanceof RegExp) {\n\t            return \"regexp\";\n\t        }\n\t    }\n\t    return propType;\n\t}\n\t\n\tfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n\t    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n\t        return mobx.untracked(function () {\n\t            if (allowNativeType) {\n\t                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;\n\t            }\n\t            var mobxChecker = void 0;\n\t            switch (mobxType) {\n\t                case \"Array\":\n\t                    mobxChecker = mobx.isObservableArray;\n\t                    break;\n\t                case \"Object\":\n\t                    mobxChecker = mobx.isObservableObject;\n\t                    break;\n\t                case \"Map\":\n\t                    mobxChecker = mobx.isObservableMap;\n\t                    break;\n\t                default:\n\t                    throw new Error(\"Unexpected mobxType: \" + mobxType);\n\t            }\n\t            var propValue = props[propName];\n\t            if (!mobxChecker(propValue)) {\n\t                var preciseType = getPreciseType(propValue);\n\t                var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n\t                return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n\t            }\n\t            return null;\n\t        });\n\t    });\n\t}\n\t\n\tfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n\t    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n\t        for (var _len2 = arguments.length, rest = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n\t            rest[_key2 - 5] = arguments[_key2];\n\t        }\n\t\n\t        return mobx.untracked(function () {\n\t            if (typeof typeChecker !== \"function\") {\n\t                return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n\t            }\n\t            var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName);\n\t            if (error instanceof Error) return error;\n\t            var propValue = props[propName];\n\t            for (var i = 0; i < propValue.length; i++) {\n\t                error = typeChecker.apply(undefined, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n\t                if (error instanceof Error) return error;\n\t            }\n\t            return null;\n\t        });\n\t    });\n\t}\n\t\n\tvar observableArray = createObservableTypeCheckerCreator(false, \"Array\");\n\tvar observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false);\n\tvar observableMap = createObservableTypeCheckerCreator(false, \"Map\");\n\tvar observableObject = createObservableTypeCheckerCreator(false, \"Object\");\n\tvar arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\");\n\tvar arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true);\n\tvar objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\");\n\t\n\t\n\t\n\tvar propTypes = Object.freeze({\n\t\tobservableArray: observableArray,\n\t\tobservableArrayOf: observableArrayOf,\n\t\tobservableMap: observableMap,\n\t\tobservableObject: observableObject,\n\t\tarrayOrObservableArray: arrayOrObservableArray,\n\t\tarrayOrObservableArrayOf: arrayOrObservableArrayOf,\n\t\tobjectOrObservableObject: objectOrObservableObject\n\t});\n\t\n\tfunction isStateless(component) {\n\t    // `function() {}` has prototype, but `() => {}` doesn't\n\t    // `() => {}` via Babel has prototype too.\n\t    return !(component.prototype && component.prototype.render);\n\t}\n\t\n\tvar injectorContextTypes = {\n\t    mobxStores: objectOrObservableObject\n\t};\n\tObject.seal(injectorContextTypes);\n\t\n\tvar proxiedInjectorProps = {\n\t    contextTypes: {\n\t        get: function get$$1() {\n\t            return injectorContextTypes;\n\t        },\n\t        set: function set$$1(_) {\n\t            console.warn(\"Mobx Injector: you are trying to attach `contextTypes` on an component decorated with `inject` (or `observer`) HOC. Please specify the contextTypes on the wrapped component instead. It is accessible through the `wrappedComponent`\");\n\t        },\n\t        configurable: true,\n\t        enumerable: false\n\t    },\n\t    isMobxInjector: {\n\t        value: true,\n\t        writable: true,\n\t        configurable: true,\n\t        enumerable: true\n\t    }\n\t\n\t    /**\n\t     * Store Injection\n\t     */\n\t};function createStoreInjector(grabStoresFn, component, injectNames) {\n\t    var _class, _temp2;\n\t\n\t    var displayName = \"inject-\" + (component.displayName || component.name || component.constructor && component.constructor.name || \"Unknown\");\n\t    if (injectNames) displayName += \"-with-\" + injectNames;\n\t\n\t    var Injector = (_temp2 = _class = function (_Component) {\n\t        inherits(Injector, _Component);\n\t\n\t        function Injector() {\n\t            var _ref;\n\t\n\t            var _temp, _this, _ret;\n\t\n\t            classCallCheck(this, Injector);\n\t\n\t            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t                args[_key] = arguments[_key];\n\t            }\n\t\n\t            return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Injector.__proto__ || Object.getPrototypeOf(Injector)).call.apply(_ref, [this].concat(args))), _this), _this.storeRef = function (instance) {\n\t                _this.wrappedInstance = instance;\n\t            }, _temp), possibleConstructorReturn(_this, _ret);\n\t        }\n\t\n\t        createClass(Injector, [{\n\t            key: \"render\",\n\t            value: function render() {\n\t                // Optimization: it might be more efficient to apply the mapper function *outside* the render method\n\t                // (if the mapper is a function), that could avoid expensive(?) re-rendering of the injector component\n\t                // See this test: 'using a custom injector is not too reactive' in inject.js\n\t                var newProps = {};\n\t                for (var key in this.props) {\n\t                    if (this.props.hasOwnProperty(key)) {\n\t                        newProps[key] = this.props[key];\n\t                    }\n\t                }var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};\n\t                for (var _key2 in additionalProps) {\n\t                    newProps[_key2] = additionalProps[_key2];\n\t                }\n\t\n\t                if (!isStateless(component)) {\n\t                    newProps.ref = this.storeRef;\n\t                }\n\t\n\t                return react.createElement(component, newProps);\n\t            }\n\t        }]);\n\t        return Injector;\n\t    }(react.Component), _class.displayName = displayName, _temp2);\n\t\n\t    // Static fields from component should be visible on the generated Injector\n\t\n\t    hoistNonReactStatics(Injector, component);\n\t\n\t    Injector.wrappedComponent = component;\n\t    Object.defineProperties(Injector, proxiedInjectorProps);\n\t\n\t    return Injector;\n\t}\n\t\n\tfunction grabStoresByName(storeNames) {\n\t    return function (baseStores, nextProps) {\n\t        storeNames.forEach(function (storeName) {\n\t            if (storeName in nextProps // prefer props over stores\n\t            ) return;\n\t            if (!(storeName in baseStores)) throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n\t            nextProps[storeName] = baseStores[storeName];\n\t        });\n\t        return nextProps;\n\t    };\n\t}\n\t\n\t/**\n\t * higher order component that injects stores to a child.\n\t * takes either a varargs list of strings, which are stores read from the context,\n\t * or a function that manually maps the available stores from the context to props:\n\t * storesToProps(mobxStores, props, context) => newProps\n\t */\n\tfunction inject() /* fn(stores, nextProps) or ...storeNames */{\n\t    var grabStoresFn = void 0;\n\t    if (typeof arguments[0] === \"function\") {\n\t        grabStoresFn = arguments[0];\n\t        return function (componentClass) {\n\t            var injected = createStoreInjector(grabStoresFn, componentClass);\n\t            injected.isMobxInjector = false; // supress warning\n\t            // mark the Injector as observer, to make it react to expressions in `grabStoresFn`,\n\t            // see #111\n\t            injected = observer(injected);\n\t            injected.isMobxInjector = true; // restore warning\n\t            return injected;\n\t        };\n\t    } else {\n\t        var storeNames = [];\n\t        for (var i = 0; i < arguments.length; i++) {\n\t            storeNames[i] = arguments[i];\n\t        }grabStoresFn = grabStoresByName(storeNames);\n\t        return function (componentClass) {\n\t            return createStoreInjector(grabStoresFn, componentClass, storeNames.join(\"-\"));\n\t        };\n\t    }\n\t}\n\t\n\t/**\n\t * dev tool support\n\t */\n\tvar isDevtoolsEnabled = false;\n\t\n\tvar isUsingStaticRendering = false;\n\t\n\tvar warnedAboutObserverInjectDeprecation = false;\n\t\n\t// WeakMap<Node, Object>;\n\tvar componentByNodeRegistery = typeof WeakMap !== \"undefined\" ? new WeakMap() : undefined;\n\tvar renderReporter = new EventEmitter();\n\t\n\tfunction findDOMNode$2(component) {\n\t    if (reactDom.findDOMNode) {\n\t        try {\n\t            return reactDom.findDOMNode(component);\n\t        } catch (e) {\n\t            // findDOMNode will throw in react-test-renderer, see:\n\t            // See https://github.com/mobxjs/mobx-react/issues/216\n\t            // Is there a better heuristic?\n\t            return null;\n\t        }\n\t    }\n\t    return null;\n\t}\n\t\n\tfunction reportRendering(component) {\n\t    var node = findDOMNode$2(component);\n\t    if (node && componentByNodeRegistery) componentByNodeRegistery.set(node, component);\n\t\n\t    renderReporter.emit({\n\t        event: \"render\",\n\t        renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,\n\t        totalTime: Date.now() - component.__$mobRenderStart,\n\t        component: component,\n\t        node: node\n\t    });\n\t}\n\t\n\tfunction trackComponents() {\n\t    if (typeof WeakMap === \"undefined\") throw new Error(\"[mobx-react] tracking components is not supported in this browser.\");\n\t    if (!isDevtoolsEnabled) isDevtoolsEnabled = true;\n\t}\n\t\n\tfunction useStaticRendering(useStaticRendering) {\n\t    isUsingStaticRendering = useStaticRendering;\n\t}\n\t\n\t/**\n\t * Errors reporter\n\t */\n\t\n\tvar errorsReporter = new EventEmitter();\n\t\n\t/**\n\t * Utilities\n\t */\n\t\n\tfunction patch(target, funcName) {\n\t    var runMixinFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t    var base = target[funcName];\n\t    var mixinFunc = reactiveMixin[funcName];\n\t    var f = !base ? mixinFunc : runMixinFirst === true ? function () {\n\t        mixinFunc.apply(this, arguments);\n\t        base.apply(this, arguments);\n\t    } : function () {\n\t        base.apply(this, arguments);\n\t        mixinFunc.apply(this, arguments);\n\t    };\n\t\n\t    // MWE: ideally we freeze here to protect against accidental overwrites in component instances, see #195\n\t    // ...but that breaks react-hot-loader, see #231...\n\t    target[funcName] = f;\n\t}\n\t\n\tfunction isObjectShallowModified(prev, next) {\n\t    if (null == prev || null == next || (typeof prev === \"undefined\" ? \"undefined\" : _typeof(prev)) !== \"object\" || (typeof next === \"undefined\" ? \"undefined\" : _typeof(next)) !== \"object\") {\n\t        return prev !== next;\n\t    }\n\t    var keys = Object.keys(prev);\n\t    if (keys.length !== Object.keys(next).length) {\n\t        return true;\n\t    }\n\t    var key = void 0;\n\t    for (var i = keys.length - 1; i >= 0, key = keys[i]; i--) {\n\t        if (next[key] !== prev[key]) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * ReactiveMixin\n\t */\n\tvar reactiveMixin = {\n\t    componentWillMount: function componentWillMount() {\n\t        var _this = this;\n\t\n\t        if (isUsingStaticRendering === true) return;\n\t        // Generate friendly name for debugging\n\t        var initialName = this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || \"<component>\";\n\t        var rootNodeID = this._reactInternalInstance && this._reactInternalInstance._rootNodeID;\n\t\n\t        /**\n\t         * If props are shallowly modified, react will render anyway,\n\t         * so atom.reportChanged() should not result in yet another re-render\n\t         */\n\t        var skipRender = false;\n\t        /**\n\t         * forceUpdate will re-assign this.props. We don't want that to cause a loop,\n\t         * so detect these changes\n\t         */\n\t        var isForcingUpdate = false;\n\t\n\t        function makePropertyObservableReference(propName) {\n\t            var valueHolder = this[propName];\n\t            var atom = new mobx.Atom(\"reactive \" + propName);\n\t            Object.defineProperty(this, propName, {\n\t                configurable: true,\n\t                enumerable: true,\n\t                get: function get$$1() {\n\t                    atom.reportObserved();\n\t                    return valueHolder;\n\t                },\n\t                set: function set$$1(v) {\n\t                    if (!isForcingUpdate && isObjectShallowModified(valueHolder, v)) {\n\t                        valueHolder = v;\n\t                        skipRender = true;\n\t                        atom.reportChanged();\n\t                        skipRender = false;\n\t                    } else {\n\t                        valueHolder = v;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // make this.props an observable reference, see #124\n\t        makePropertyObservableReference.call(this, \"props\");\n\t        // make state an observable reference\n\t        makePropertyObservableReference.call(this, \"state\");\n\t\n\t        // wire up reactive render\n\t        var baseRender = this.render.bind(this);\n\t        var reaction = null;\n\t        var isRenderingPending = false;\n\t\n\t        var initialRender = function initialRender() {\n\t            reaction = new mobx.Reaction(initialName + \"#\" + rootNodeID + \".render()\", function () {\n\t                if (!isRenderingPending) {\n\t                    // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n\t                    // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n\t                    // See #85 / Pull #44\n\t                    isRenderingPending = true;\n\t                    if (typeof _this.componentWillReact === \"function\") _this.componentWillReact(); // TODO: wrap in action?\n\t                    if (_this.__$mobxIsUnmounted !== true) {\n\t                        // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted\n\t                        // TODO: remove this check? Then react will properly warn about the fact that this should not happen? See #73\n\t                        // However, people also claim this migth happen during unit tests..\n\t                        var hasError = true;\n\t                        try {\n\t                            isForcingUpdate = true;\n\t                            if (!skipRender) react.Component.prototype.forceUpdate.call(_this);\n\t                            hasError = false;\n\t                        } finally {\n\t                            isForcingUpdate = false;\n\t                            if (hasError) reaction.dispose();\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t            reaction.reactComponent = _this;\n\t            reactiveRender.$mobx = reaction;\n\t            _this.render = reactiveRender;\n\t            return reactiveRender();\n\t        };\n\t\n\t        var reactiveRender = function reactiveRender() {\n\t            isRenderingPending = false;\n\t            var exception = undefined;\n\t            var rendering = undefined;\n\t            reaction.track(function () {\n\t                if (isDevtoolsEnabled) {\n\t                    _this.__$mobRenderStart = Date.now();\n\t                }\n\t                try {\n\t                    rendering = mobx.extras.allowStateChanges(false, baseRender);\n\t                } catch (e) {\n\t                    exception = e;\n\t                }\n\t                if (isDevtoolsEnabled) {\n\t                    _this.__$mobRenderEnd = Date.now();\n\t                }\n\t            });\n\t            if (exception) {\n\t                errorsReporter.emit(exception);\n\t                throw exception;\n\t            }\n\t            return rendering;\n\t        };\n\t\n\t        this.render = initialRender;\n\t    },\n\t\n\t    componentWillUnmount: function componentWillUnmount() {\n\t        if (isUsingStaticRendering === true) return;\n\t        this.render.$mobx && this.render.$mobx.dispose();\n\t        this.__$mobxIsUnmounted = true;\n\t        if (isDevtoolsEnabled) {\n\t            var node = findDOMNode$2(this);\n\t            if (node && componentByNodeRegistery) {\n\t                componentByNodeRegistery.delete(node);\n\t            }\n\t            renderReporter.emit({\n\t                event: \"destroy\",\n\t                component: this,\n\t                node: node\n\t            });\n\t        }\n\t    },\n\t\n\t    componentDidMount: function componentDidMount() {\n\t        if (isDevtoolsEnabled) {\n\t            reportRendering(this);\n\t        }\n\t    },\n\t\n\t    componentDidUpdate: function componentDidUpdate() {\n\t        if (isDevtoolsEnabled) {\n\t            reportRendering(this);\n\t        }\n\t    },\n\t\n\t    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {\n\t        if (isUsingStaticRendering) {\n\t            console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n\t        }\n\t        // update on any state changes (as is the default)\n\t        if (this.state !== nextState) {\n\t            return true;\n\t        }\n\t        // update if props are shallowly not equal, inspired by PureRenderMixin\n\t        // we could return just 'false' here, and avoid the `skipRender` checks etc\n\t        // however, it is nicer if lifecycle events are triggered like usually,\n\t        // so we return true here if props are shallowly modified.\n\t        return isObjectShallowModified(this.props, nextProps);\n\t    }\n\t\n\t    /**\n\t     * Observer function / decorator\n\t     */\n\t};function observer(arg1, arg2) {\n\t    if (typeof arg1 === \"string\") {\n\t        throw new Error(\"Store names should be provided as array\");\n\t    }\n\t    if (Array.isArray(arg1)) {\n\t        // component needs stores\n\t        if (!warnedAboutObserverInjectDeprecation) {\n\t            warnedAboutObserverInjectDeprecation = true;\n\t            console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject(\"store1\", \"store2\") @observer ComponentClass` or `inject(\"store1\", \"store2\")(observer(componentClass))` instead of `@observer([\"store1\", \"store2\"]) ComponentClass`');\n\t        }\n\t        if (!arg2) {\n\t            // invoked as decorator\n\t            return function (componentClass) {\n\t                return observer(arg1, componentClass);\n\t            };\n\t        } else {\n\t            return inject.apply(null, arg1)(observer(arg2));\n\t        }\n\t    }\n\t    var componentClass = arg1;\n\t\n\t    if (componentClass.isMobxInjector === true) {\n\t        console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\");\n\t    }\n\t\n\t    // Stateless function component:\n\t    // If it is function but doesn't seem to be a react class constructor,\n\t    // wrap it to a react class automatically\n\t    if (typeof componentClass === \"function\" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !react.Component.isPrototypeOf(componentClass)) {\n\t        var _class, _temp;\n\t\n\t        return observer((_temp = _class = function (_Component) {\n\t            inherits(_class, _Component);\n\t\n\t            function _class() {\n\t                classCallCheck(this, _class);\n\t                return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n\t            }\n\t\n\t            createClass(_class, [{\n\t                key: \"render\",\n\t                value: function render() {\n\t                    return componentClass.call(this, this.props, this.context);\n\t                }\n\t            }]);\n\t            return _class;\n\t        }(react.Component), _class.displayName = componentClass.displayName || componentClass.name, _class.contextTypes = componentClass.contextTypes, _class.propTypes = componentClass.propTypes, _class.defaultProps = componentClass.defaultProps, _temp));\n\t    }\n\t\n\t    if (!componentClass) {\n\t        throw new Error(\"Please pass a valid component to 'observer'\");\n\t    }\n\t\n\t    var target = componentClass.prototype || componentClass;\n\t    mixinLifecycleEvents(target);\n\t    componentClass.isMobXReactObserver = true;\n\t    return componentClass;\n\t}\n\t\n\tfunction mixinLifecycleEvents(target) {\n\t    patch(target, \"componentWillMount\", true);[\"componentDidMount\", \"componentWillUnmount\", \"componentDidUpdate\"].forEach(function (funcName) {\n\t        patch(target, funcName);\n\t    });\n\t    if (!target.shouldComponentUpdate) {\n\t        target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;\n\t    }\n\t}\n\t\n\t// TODO: support injection somehow as well?\n\tvar Observer = observer(function (_ref) {\n\t    var children = _ref.children;\n\t    return children();\n\t});\n\t\n\tObserver.propTypes = {\n\t    children: function children(propValue, key, componentName, location, propFullName) {\n\t        if (typeof propValue[key] !== \"function\") return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + _typeof(propValue[key]) + \"` supplied to\" + \" `\" + componentName + \"`, expected `function`.\");\n\t    }\n\t};\n\t\n\tvar _class;\n\tvar _temp;\n\t\n\tvar specialReactKeys = { children: true, key: true, ref: true };\n\t\n\tvar Provider = (_temp = _class = function (_Component) {\n\t    inherits(Provider, _Component);\n\t\n\t    function Provider() {\n\t        classCallCheck(this, Provider);\n\t        return possibleConstructorReturn(this, (Provider.__proto__ || Object.getPrototypeOf(Provider)).apply(this, arguments));\n\t    }\n\t\n\t    createClass(Provider, [{\n\t        key: \"render\",\n\t        value: function render() {\n\t            return react.Children.only(this.props.children);\n\t        }\n\t    }, {\n\t        key: \"getChildContext\",\n\t        value: function getChildContext() {\n\t            var stores = {};\n\t            // inherit stores\n\t            var baseStores = this.context.mobxStores;\n\t            if (baseStores) for (var key in baseStores) {\n\t                stores[key] = baseStores[key];\n\t            }\n\t            // add own stores\n\t            for (var _key in this.props) {\n\t                if (!specialReactKeys[_key] && _key !== \"suppressChangedStoreWarning\") stores[_key] = this.props[_key];\n\t            }return {\n\t                mobxStores: stores\n\t            };\n\t        }\n\t    }, {\n\t        key: \"componentWillReceiveProps\",\n\t        value: function componentWillReceiveProps(nextProps) {\n\t            // Maybe this warning is too aggressive?\n\t            if (Object.keys(nextProps).length !== Object.keys(this.props).length) console.warn(\"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\");\n\t            if (!nextProps.suppressChangedStoreWarning) for (var key in nextProps) {\n\t                if (!specialReactKeys[key] && this.props[key] !== nextProps[key]) console.warn(\"MobX Provider: Provided store '\" + key + \"' has changed. Please avoid replacing stores as the change might not propagate to all children\");\n\t            }\n\t        }\n\t    }]);\n\t    return Provider;\n\t}(react.Component), _class.contextTypes = {\n\t    mobxStores: objectOrObservableObject\n\t}, _class.childContextTypes = {\n\t    mobxStores: objectOrObservableObject.isRequired\n\t}, _temp);\n\t\n\tif (!react.Component) throw new Error('mobx-react requires React to be available');\n\tif (!mobx.extras) throw new Error('mobx-react requires mobx to be available');\n\t\n\tif (typeof reactDom.unstable_batchedUpdates === \"function\") mobx.extras.setReactionScheduler(reactDom.unstable_batchedUpdates);else if (typeof unstable_batchedUpdates$1 === \"function\") mobx.extras.setReactionScheduler(unstable_batchedUpdates$1);\n\t\n\tvar onError = function onError(fn) {\n\t  return errorsReporter.on(fn);\n\t};\n\t\n\t/* DevTool support */\n\t// See: https://github.com/andykog/mobx-devtools/blob/d8976c24b8cb727ed59f9a0bc905a009df79e221/src/backend/installGlobalHook.js\n\t\n\tif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ? 'undefined' : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === 'object') {\n\t  var mobx$1 = { spy: mobx.spy, extras: mobx.extras };\n\t  var mobxReact = { renderReporter: renderReporter, componentByNodeRegistery: componentByNodeRegistery, trackComponents: trackComponents };\n\t  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact(mobxReact, mobx$1);\n\t}\n\t\n\texports.propTypes = propTypes;\n\texports.PropTypes = propTypes;\n\texports.onError = onError;\n\texports.observer = observer;\n\texports.Observer = Observer;\n\texports.renderReporter = renderReporter;\n\texports.componentByNodeRegistery = componentByNodeRegistery;\n\texports.trackComponents = trackComponents;\n\texports.useStaticRendering = useStaticRendering;\n\texports.Provider = Provider;\n\texports.inject = inject;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 103:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.default = undefined;\n\t\n\tvar _templateObject = _taggedTemplateLiteralLoose(['\\n  position: absolute;\\n  top: 0; bottom: 0; right: 0; left: 0;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  color: ', ';\\n\\n  .content-container{\\n    display: block;\\n    text-align: center;\\n  }\\n'], ['\\n  position: absolute;\\n  top: 0; bottom: 0; right: 0; left: 0;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  color: ', ';\\n\\n  .content-container{\\n    display: block;\\n    text-align: center;\\n  }\\n']);\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _propTypes = __webpack_require__(1);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _styledComponents = __webpack_require__(6);\n\t\n\tvar _styledComponents2 = _interopRequireDefault(_styledComponents);\n\t\n\tvar _styles = __webpack_require__(8);\n\t\n\tvar _styles2 = _interopRequireDefault(_styles);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar EmptyPage = function (_React$Component) {\n\t  _inherits(EmptyPage, _React$Component);\n\t\n\t  function EmptyPage(props) {\n\t    _classCallCheck(this, EmptyPage);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component.call(this, props));\n\t  }\n\t\n\t  EmptyPage.prototype.render = function render() {\n\t    return _react2.default.createElement(\n\t      'div',\n\t      { className: 'empty-page' },\n\t      _react2.default.createElement(\n\t        'div',\n\t        { className: 'content-container' },\n\t        _react2.default.createElement(\n\t          'h1',\n\t          null,\n\t          this.props.title\n\t        ),\n\t        this.props.message ? _react2.default.createElement(\n\t          'p',\n\t          null,\n\t          this.props.message\n\t        ) : null\n\t      )\n\t    );\n\t  };\n\t\n\t  return EmptyPage;\n\t}(_react2.default.Component);\n\t\n\t// STYLES\n\t\n\t\n\texports.default = EmptyPage;\n\tvar EmptyPageComponent = _styledComponents2.default.div(_templateObject, _styles2.default.color.base);\n\t\n\tEmptyPage.propTypes = {\n\t  title: _propTypes2.default.string.isRequired,\n\t  message: _propTypes2.default.string\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 297:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.default = undefined;\n\t\n\tvar _class;\n\t// import modules here\n\t\n\t\n\tvar _mobxReact = __webpack_require__(34);\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _propTypes = __webpack_require__(1);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _Page = __webpack_require__(41);\n\t\n\tvar _Page2 = _interopRequireDefault(_Page);\n\t\n\tvar _AppState = __webpack_require__(16);\n\t\n\tvar _AppState2 = _interopRequireDefault(_AppState);\n\t\n\tvar _TypeState = __webpack_require__(30);\n\t\n\tvar _TypeState2 = _interopRequireDefault(_TypeState);\n\t\n\tvar _objectType = __webpack_require__(40);\n\t\n\tvar _objectType2 = _interopRequireDefault(_objectType);\n\t\n\tvar _CreateType = __webpack_require__(175);\n\t\n\tvar _CreateType2 = _interopRequireDefault(_CreateType);\n\t\n\tvar _EmptyPage = __webpack_require__(103);\n\t\n\tvar _EmptyPage2 = _interopRequireDefault(_EmptyPage);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Modules = (0, _mobxReact.observer)(_class = function (_React$Component) {\n\t  _inherits(Modules, _React$Component);\n\t\n\t  function Modules(props) {\n\t    _classCallCheck(this, Modules);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component.call(this, props));\n\t  }\n\t\n\t  Modules.prototype.getModuleTypes = function getModuleTypes() {\n\t    var moduleTypes = [];\n\t    var types = _TypeState2.default.orderedUserMadeTypeList;\n\t    for (var i = 0; i < types.length; i++) {\n\t      var type = types[i].data;\n\t      moduleTypes.push(_react2.default.createElement(_CreateType2.default, { key: 'construct-type-' + type.id, type: type }));\n\t    }\n\t    return moduleTypes;\n\t  };\n\t\n\t  Modules.prototype.render = function render() {\n\t    var moduleTypes = this.getModuleTypes();\n\t    var child = null;\n\t    if (moduleTypes.length > 0) {\n\t      child = moduleTypes;\n\t    } else {\n\t      child = _react2.default.createElement(_EmptyPage2.default, { title: 'No Modules', message: 'Press the + button in the bottom right to add a module' });\n\t    }\n\t    return _react2.default.createElement(\n\t      _Page2.default,\n\t      { id: 'Modules', title: 'Modules' },\n\t      child\n\t    );\n\t  };\n\t\n\t  return Modules;\n\t}(_react2.default.Component)) || _class;\n\t\n\texports.default = Modules;\n\t\n\t\n\tModules.propTypes = {\n\t  state: _propTypes2.default.instanceOf(_AppState2.default)\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-modules-jsx-337ddb301ec17331477b.js","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('mobx'), require('react'), require('react-dom')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'mobx', 'react', 'react-dom'], factory) :\n\t(factory((global.mobxReact = {}),global.mobx,global.React,global.ReactDOM));\n}(this, (function (exports,mobx,react,reactDom) { 'use strict';\n\n// These functions can be stubbed out in specific environments\nvar unstable_batchedUpdates$1 = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar EventEmitter = function () {\n    function EventEmitter() {\n        classCallCheck(this, EventEmitter);\n        this.listeners = [];\n    }\n\n    createClass(EventEmitter, [{\n        key: \"on\",\n        value: function on(cb) {\n            var _this = this;\n\n            this.listeners.push(cb);\n            return function () {\n                var index = _this.listeners.indexOf(cb);\n                if (index !== -1) _this.listeners.splice(index, 1);\n            };\n        }\n    }, {\n        key: \"emit\",\n        value: function emit(data) {\n            this.listeners.forEach(function (fn) {\n                return fn(data);\n            });\n        }\n    }]);\n    return EventEmitter;\n}();\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\n\nvar defineProperty$1 = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\nvar hoistNonReactStatics = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n\n        var keys = getOwnPropertyNames(sourceComponent);\n\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try { // Avoid failures from read-only properties\n                    defineProperty$1(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n\n        return targetComponent;\n    }\n\n    return targetComponent;\n};\n\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validate) {\n    function checkType(isRequired, props, propName, componentName, location, propFullName) {\n        for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n            rest[_key - 6] = arguments[_key];\n        }\n\n        return mobx.untracked(function () {\n            componentName = componentName || \"<<anonymous>>\";\n            propFullName = propFullName || propName;\n            if (props[propName] == null) {\n                if (isRequired) {\n                    var actual = props[propName] === null ? \"null\" : \"undefined\";\n                    return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n                }\n                return null;\n            } else {\n                return validate.apply(undefined, [props, propName, componentName, location, propFullName].concat(rest));\n            }\n        });\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n    return chainedCheckType;\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true;\n    }\n\n    return false;\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    var propType = typeof propValue === \"undefined\" ? \"undefined\" : _typeof(propValue);\n    if (Array.isArray(propValue)) {\n        return \"array\";\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\";\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\";\n    }\n    return propType;\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    var propType = getPropType(propValue);\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\";\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\";\n        }\n    }\n    return propType;\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        return mobx.untracked(function () {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;\n            }\n            var mobxChecker = void 0;\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = mobx.isObservableArray;\n                    break;\n                case \"Object\":\n                    mobxChecker = mobx.isObservableObject;\n                    break;\n                case \"Map\":\n                    mobxChecker = mobx.isObservableMap;\n                    break;\n                default:\n                    throw new Error(\"Unexpected mobxType: \" + mobxType);\n            }\n            var propValue = props[propName];\n            if (!mobxChecker(propValue)) {\n                var preciseType = getPreciseType(propValue);\n                var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n                return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n            }\n            return null;\n        });\n    });\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        for (var _len2 = arguments.length, rest = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n            rest[_key2 - 5] = arguments[_key2];\n        }\n\n        return mobx.untracked(function () {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n            }\n            var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName);\n            if (error instanceof Error) return error;\n            var propValue = props[propName];\n            for (var i = 0; i < propValue.length; i++) {\n                error = typeChecker.apply(undefined, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n                if (error instanceof Error) return error;\n            }\n            return null;\n        });\n    });\n}\n\nvar observableArray = createObservableTypeCheckerCreator(false, \"Array\");\nvar observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false);\nvar observableMap = createObservableTypeCheckerCreator(false, \"Map\");\nvar observableObject = createObservableTypeCheckerCreator(false, \"Object\");\nvar arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\");\nvar arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true);\nvar objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\");\n\n\n\nvar propTypes = Object.freeze({\n\tobservableArray: observableArray,\n\tobservableArrayOf: observableArrayOf,\n\tobservableMap: observableMap,\n\tobservableObject: observableObject,\n\tarrayOrObservableArray: arrayOrObservableArray,\n\tarrayOrObservableArrayOf: arrayOrObservableArrayOf,\n\tobjectOrObservableObject: objectOrObservableObject\n});\n\nfunction isStateless(component) {\n    // `function() {}` has prototype, but `() => {}` doesn't\n    // `() => {}` via Babel has prototype too.\n    return !(component.prototype && component.prototype.render);\n}\n\nvar injectorContextTypes = {\n    mobxStores: objectOrObservableObject\n};\nObject.seal(injectorContextTypes);\n\nvar proxiedInjectorProps = {\n    contextTypes: {\n        get: function get$$1() {\n            return injectorContextTypes;\n        },\n        set: function set$$1(_) {\n            console.warn(\"Mobx Injector: you are trying to attach `contextTypes` on an component decorated with `inject` (or `observer`) HOC. Please specify the contextTypes on the wrapped component instead. It is accessible through the `wrappedComponent`\");\n        },\n        configurable: true,\n        enumerable: false\n    },\n    isMobxInjector: {\n        value: true,\n        writable: true,\n        configurable: true,\n        enumerable: true\n    }\n\n    /**\n     * Store Injection\n     */\n};function createStoreInjector(grabStoresFn, component, injectNames) {\n    var _class, _temp2;\n\n    var displayName = \"inject-\" + (component.displayName || component.name || component.constructor && component.constructor.name || \"Unknown\");\n    if (injectNames) displayName += \"-with-\" + injectNames;\n\n    var Injector = (_temp2 = _class = function (_Component) {\n        inherits(Injector, _Component);\n\n        function Injector() {\n            var _ref;\n\n            var _temp, _this, _ret;\n\n            classCallCheck(this, Injector);\n\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Injector.__proto__ || Object.getPrototypeOf(Injector)).call.apply(_ref, [this].concat(args))), _this), _this.storeRef = function (instance) {\n                _this.wrappedInstance = instance;\n            }, _temp), possibleConstructorReturn(_this, _ret);\n        }\n\n        createClass(Injector, [{\n            key: \"render\",\n            value: function render() {\n                // Optimization: it might be more efficient to apply the mapper function *outside* the render method\n                // (if the mapper is a function), that could avoid expensive(?) re-rendering of the injector component\n                // See this test: 'using a custom injector is not too reactive' in inject.js\n                var newProps = {};\n                for (var key in this.props) {\n                    if (this.props.hasOwnProperty(key)) {\n                        newProps[key] = this.props[key];\n                    }\n                }var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};\n                for (var _key2 in additionalProps) {\n                    newProps[_key2] = additionalProps[_key2];\n                }\n\n                if (!isStateless(component)) {\n                    newProps.ref = this.storeRef;\n                }\n\n                return react.createElement(component, newProps);\n            }\n        }]);\n        return Injector;\n    }(react.Component), _class.displayName = displayName, _temp2);\n\n    // Static fields from component should be visible on the generated Injector\n\n    hoistNonReactStatics(Injector, component);\n\n    Injector.wrappedComponent = component;\n    Object.defineProperties(Injector, proxiedInjectorProps);\n\n    return Injector;\n}\n\nfunction grabStoresByName(storeNames) {\n    return function (baseStores, nextProps) {\n        storeNames.forEach(function (storeName) {\n            if (storeName in nextProps // prefer props over stores\n            ) return;\n            if (!(storeName in baseStores)) throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n            nextProps[storeName] = baseStores[storeName];\n        });\n        return nextProps;\n    };\n}\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nfunction inject() /* fn(stores, nextProps) or ...storeNames */{\n    var grabStoresFn = void 0;\n    if (typeof arguments[0] === \"function\") {\n        grabStoresFn = arguments[0];\n        return function (componentClass) {\n            var injected = createStoreInjector(grabStoresFn, componentClass);\n            injected.isMobxInjector = false; // supress warning\n            // mark the Injector as observer, to make it react to expressions in `grabStoresFn`,\n            // see #111\n            injected = observer(injected);\n            injected.isMobxInjector = true; // restore warning\n            return injected;\n        };\n    } else {\n        var storeNames = [];\n        for (var i = 0; i < arguments.length; i++) {\n            storeNames[i] = arguments[i];\n        }grabStoresFn = grabStoresByName(storeNames);\n        return function (componentClass) {\n            return createStoreInjector(grabStoresFn, componentClass, storeNames.join(\"-\"));\n        };\n    }\n}\n\n/**\n * dev tool support\n */\nvar isDevtoolsEnabled = false;\n\nvar isUsingStaticRendering = false;\n\nvar warnedAboutObserverInjectDeprecation = false;\n\n// WeakMap<Node, Object>;\nvar componentByNodeRegistery = typeof WeakMap !== \"undefined\" ? new WeakMap() : undefined;\nvar renderReporter = new EventEmitter();\n\nfunction findDOMNode$2(component) {\n    if (reactDom.findDOMNode) {\n        try {\n            return reactDom.findDOMNode(component);\n        } catch (e) {\n            // findDOMNode will throw in react-test-renderer, see:\n            // See https://github.com/mobxjs/mobx-react/issues/216\n            // Is there a better heuristic?\n            return null;\n        }\n    }\n    return null;\n}\n\nfunction reportRendering(component) {\n    var node = findDOMNode$2(component);\n    if (node && componentByNodeRegistery) componentByNodeRegistery.set(node, component);\n\n    renderReporter.emit({\n        event: \"render\",\n        renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,\n        totalTime: Date.now() - component.__$mobRenderStart,\n        component: component,\n        node: node\n    });\n}\n\nfunction trackComponents() {\n    if (typeof WeakMap === \"undefined\") throw new Error(\"[mobx-react] tracking components is not supported in this browser.\");\n    if (!isDevtoolsEnabled) isDevtoolsEnabled = true;\n}\n\nfunction useStaticRendering(useStaticRendering) {\n    isUsingStaticRendering = useStaticRendering;\n}\n\n/**\n * Errors reporter\n */\n\nvar errorsReporter = new EventEmitter();\n\n/**\n * Utilities\n */\n\nfunction patch(target, funcName) {\n    var runMixinFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var base = target[funcName];\n    var mixinFunc = reactiveMixin[funcName];\n    var f = !base ? mixinFunc : runMixinFirst === true ? function () {\n        mixinFunc.apply(this, arguments);\n        base.apply(this, arguments);\n    } : function () {\n        base.apply(this, arguments);\n        mixinFunc.apply(this, arguments);\n    };\n\n    // MWE: ideally we freeze here to protect against accidental overwrites in component instances, see #195\n    // ...but that breaks react-hot-loader, see #231...\n    target[funcName] = f;\n}\n\nfunction isObjectShallowModified(prev, next) {\n    if (null == prev || null == next || (typeof prev === \"undefined\" ? \"undefined\" : _typeof(prev)) !== \"object\" || (typeof next === \"undefined\" ? \"undefined\" : _typeof(next)) !== \"object\") {\n        return prev !== next;\n    }\n    var keys = Object.keys(prev);\n    if (keys.length !== Object.keys(next).length) {\n        return true;\n    }\n    var key = void 0;\n    for (var i = keys.length - 1; i >= 0, key = keys[i]; i--) {\n        if (next[key] !== prev[key]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * ReactiveMixin\n */\nvar reactiveMixin = {\n    componentWillMount: function componentWillMount() {\n        var _this = this;\n\n        if (isUsingStaticRendering === true) return;\n        // Generate friendly name for debugging\n        var initialName = this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || \"<component>\";\n        var rootNodeID = this._reactInternalInstance && this._reactInternalInstance._rootNodeID;\n\n        /**\n         * If props are shallowly modified, react will render anyway,\n         * so atom.reportChanged() should not result in yet another re-render\n         */\n        var skipRender = false;\n        /**\n         * forceUpdate will re-assign this.props. We don't want that to cause a loop,\n         * so detect these changes\n         */\n        var isForcingUpdate = false;\n\n        function makePropertyObservableReference(propName) {\n            var valueHolder = this[propName];\n            var atom = new mobx.Atom(\"reactive \" + propName);\n            Object.defineProperty(this, propName, {\n                configurable: true,\n                enumerable: true,\n                get: function get$$1() {\n                    atom.reportObserved();\n                    return valueHolder;\n                },\n                set: function set$$1(v) {\n                    if (!isForcingUpdate && isObjectShallowModified(valueHolder, v)) {\n                        valueHolder = v;\n                        skipRender = true;\n                        atom.reportChanged();\n                        skipRender = false;\n                    } else {\n                        valueHolder = v;\n                    }\n                }\n            });\n        }\n\n        // make this.props an observable reference, see #124\n        makePropertyObservableReference.call(this, \"props\");\n        // make state an observable reference\n        makePropertyObservableReference.call(this, \"state\");\n\n        // wire up reactive render\n        var baseRender = this.render.bind(this);\n        var reaction = null;\n        var isRenderingPending = false;\n\n        var initialRender = function initialRender() {\n            reaction = new mobx.Reaction(initialName + \"#\" + rootNodeID + \".render()\", function () {\n                if (!isRenderingPending) {\n                    // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n                    // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n                    // See #85 / Pull #44\n                    isRenderingPending = true;\n                    if (typeof _this.componentWillReact === \"function\") _this.componentWillReact(); // TODO: wrap in action?\n                    if (_this.__$mobxIsUnmounted !== true) {\n                        // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted\n                        // TODO: remove this check? Then react will properly warn about the fact that this should not happen? See #73\n                        // However, people also claim this migth happen during unit tests..\n                        var hasError = true;\n                        try {\n                            isForcingUpdate = true;\n                            if (!skipRender) react.Component.prototype.forceUpdate.call(_this);\n                            hasError = false;\n                        } finally {\n                            isForcingUpdate = false;\n                            if (hasError) reaction.dispose();\n                        }\n                    }\n                }\n            });\n            reaction.reactComponent = _this;\n            reactiveRender.$mobx = reaction;\n            _this.render = reactiveRender;\n            return reactiveRender();\n        };\n\n        var reactiveRender = function reactiveRender() {\n            isRenderingPending = false;\n            var exception = undefined;\n            var rendering = undefined;\n            reaction.track(function () {\n                if (isDevtoolsEnabled) {\n                    _this.__$mobRenderStart = Date.now();\n                }\n                try {\n                    rendering = mobx.extras.allowStateChanges(false, baseRender);\n                } catch (e) {\n                    exception = e;\n                }\n                if (isDevtoolsEnabled) {\n                    _this.__$mobRenderEnd = Date.now();\n                }\n            });\n            if (exception) {\n                errorsReporter.emit(exception);\n                throw exception;\n            }\n            return rendering;\n        };\n\n        this.render = initialRender;\n    },\n\n    componentWillUnmount: function componentWillUnmount() {\n        if (isUsingStaticRendering === true) return;\n        this.render.$mobx && this.render.$mobx.dispose();\n        this.__$mobxIsUnmounted = true;\n        if (isDevtoolsEnabled) {\n            var node = findDOMNode$2(this);\n            if (node && componentByNodeRegistery) {\n                componentByNodeRegistery.delete(node);\n            }\n            renderReporter.emit({\n                event: \"destroy\",\n                component: this,\n                node: node\n            });\n        }\n    },\n\n    componentDidMount: function componentDidMount() {\n        if (isDevtoolsEnabled) {\n            reportRendering(this);\n        }\n    },\n\n    componentDidUpdate: function componentDidUpdate() {\n        if (isDevtoolsEnabled) {\n            reportRendering(this);\n        }\n    },\n\n    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {\n        if (isUsingStaticRendering) {\n            console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n        }\n        // update on any state changes (as is the default)\n        if (this.state !== nextState) {\n            return true;\n        }\n        // update if props are shallowly not equal, inspired by PureRenderMixin\n        // we could return just 'false' here, and avoid the `skipRender` checks etc\n        // however, it is nicer if lifecycle events are triggered like usually,\n        // so we return true here if props are shallowly modified.\n        return isObjectShallowModified(this.props, nextProps);\n    }\n\n    /**\n     * Observer function / decorator\n     */\n};function observer(arg1, arg2) {\n    if (typeof arg1 === \"string\") {\n        throw new Error(\"Store names should be provided as array\");\n    }\n    if (Array.isArray(arg1)) {\n        // component needs stores\n        if (!warnedAboutObserverInjectDeprecation) {\n            warnedAboutObserverInjectDeprecation = true;\n            console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject(\"store1\", \"store2\") @observer ComponentClass` or `inject(\"store1\", \"store2\")(observer(componentClass))` instead of `@observer([\"store1\", \"store2\"]) ComponentClass`');\n        }\n        if (!arg2) {\n            // invoked as decorator\n            return function (componentClass) {\n                return observer(arg1, componentClass);\n            };\n        } else {\n            return inject.apply(null, arg1)(observer(arg2));\n        }\n    }\n    var componentClass = arg1;\n\n    if (componentClass.isMobxInjector === true) {\n        console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\");\n    }\n\n    // Stateless function component:\n    // If it is function but doesn't seem to be a react class constructor,\n    // wrap it to a react class automatically\n    if (typeof componentClass === \"function\" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !react.Component.isPrototypeOf(componentClass)) {\n        var _class, _temp;\n\n        return observer((_temp = _class = function (_Component) {\n            inherits(_class, _Component);\n\n            function _class() {\n                classCallCheck(this, _class);\n                return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n            }\n\n            createClass(_class, [{\n                key: \"render\",\n                value: function render() {\n                    return componentClass.call(this, this.props, this.context);\n                }\n            }]);\n            return _class;\n        }(react.Component), _class.displayName = componentClass.displayName || componentClass.name, _class.contextTypes = componentClass.contextTypes, _class.propTypes = componentClass.propTypes, _class.defaultProps = componentClass.defaultProps, _temp));\n    }\n\n    if (!componentClass) {\n        throw new Error(\"Please pass a valid component to 'observer'\");\n    }\n\n    var target = componentClass.prototype || componentClass;\n    mixinLifecycleEvents(target);\n    componentClass.isMobXReactObserver = true;\n    return componentClass;\n}\n\nfunction mixinLifecycleEvents(target) {\n    patch(target, \"componentWillMount\", true);[\"componentDidMount\", \"componentWillUnmount\", \"componentDidUpdate\"].forEach(function (funcName) {\n        patch(target, funcName);\n    });\n    if (!target.shouldComponentUpdate) {\n        target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;\n    }\n}\n\n// TODO: support injection somehow as well?\nvar Observer = observer(function (_ref) {\n    var children = _ref.children;\n    return children();\n});\n\nObserver.propTypes = {\n    children: function children(propValue, key, componentName, location, propFullName) {\n        if (typeof propValue[key] !== \"function\") return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + _typeof(propValue[key]) + \"` supplied to\" + \" `\" + componentName + \"`, expected `function`.\");\n    }\n};\n\nvar _class;\nvar _temp;\n\nvar specialReactKeys = { children: true, key: true, ref: true };\n\nvar Provider = (_temp = _class = function (_Component) {\n    inherits(Provider, _Component);\n\n    function Provider() {\n        classCallCheck(this, Provider);\n        return possibleConstructorReturn(this, (Provider.__proto__ || Object.getPrototypeOf(Provider)).apply(this, arguments));\n    }\n\n    createClass(Provider, [{\n        key: \"render\",\n        value: function render() {\n            return react.Children.only(this.props.children);\n        }\n    }, {\n        key: \"getChildContext\",\n        value: function getChildContext() {\n            var stores = {};\n            // inherit stores\n            var baseStores = this.context.mobxStores;\n            if (baseStores) for (var key in baseStores) {\n                stores[key] = baseStores[key];\n            }\n            // add own stores\n            for (var _key in this.props) {\n                if (!specialReactKeys[_key] && _key !== \"suppressChangedStoreWarning\") stores[_key] = this.props[_key];\n            }return {\n                mobxStores: stores\n            };\n        }\n    }, {\n        key: \"componentWillReceiveProps\",\n        value: function componentWillReceiveProps(nextProps) {\n            // Maybe this warning is too aggressive?\n            if (Object.keys(nextProps).length !== Object.keys(this.props).length) console.warn(\"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\");\n            if (!nextProps.suppressChangedStoreWarning) for (var key in nextProps) {\n                if (!specialReactKeys[key] && this.props[key] !== nextProps[key]) console.warn(\"MobX Provider: Provided store '\" + key + \"' has changed. Please avoid replacing stores as the change might not propagate to all children\");\n            }\n        }\n    }]);\n    return Provider;\n}(react.Component), _class.contextTypes = {\n    mobxStores: objectOrObservableObject\n}, _class.childContextTypes = {\n    mobxStores: objectOrObservableObject.isRequired\n}, _temp);\n\nif (!react.Component) throw new Error('mobx-react requires React to be available');\nif (!mobx.extras) throw new Error('mobx-react requires mobx to be available');\n\nif (typeof reactDom.unstable_batchedUpdates === \"function\") mobx.extras.setReactionScheduler(reactDom.unstable_batchedUpdates);else if (typeof unstable_batchedUpdates$1 === \"function\") mobx.extras.setReactionScheduler(unstable_batchedUpdates$1);\n\nvar onError = function onError(fn) {\n  return errorsReporter.on(fn);\n};\n\n/* DevTool support */\n// See: https://github.com/andykog/mobx-devtools/blob/d8976c24b8cb727ed59f9a0bc905a009df79e221/src/backend/installGlobalHook.js\n\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ? 'undefined' : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === 'object') {\n  var mobx$1 = { spy: mobx.spy, extras: mobx.extras };\n  var mobxReact = { renderReporter: renderReporter, componentByNodeRegistery: componentByNodeRegistery, trackComponents: trackComponents };\n  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact(mobxReact, mobx$1);\n}\n\nexports.propTypes = propTypes;\nexports.PropTypes = propTypes;\nexports.onError = onError;\nexports.observer = observer;\nexports.Observer = Observer;\nexports.renderReporter = renderReporter;\nexports.componentByNodeRegistery = componentByNodeRegistery;\nexports.trackComponents = trackComponents;\nexports.useStaticRendering = useStaticRendering;\nexports.Provider = Provider;\nexports.inject = inject;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/mobx-react/index.js\n// module id = 34\n// module chunks = 29644012231294 67960563877519 114276838955818 213534597649335","import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\nimport styles from '../styles'\n\nexport default class EmptyPage extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n\n  render() {\n    return (\n      <div className=\"empty-page\">\n        <div className=\"content-container\">\n          <h1>{this.props.title}</h1>\n          {this.props.message ? <p>{this.props.message}</p> : null}\n        </div>\n      </div>\n    )\n  }\n}\n\n// STYLES\nconst EmptyPageComponent = styled.div`\n  position: absolute;\n  top: 0; bottom: 0; right: 0; left: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: ${styles.color.base};\n\n  .content-container{\n    display: block;\n    text-align: center;\n  }\n`\n\nEmptyPage.propTypes = {\n  title: PropTypes.string.isRequired,\n  message: PropTypes.string,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/EmptyPage.jsx","import { observer } from \"mobx-react\"\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport Page from './Page.jsx'\nimport AppState from '../state/AppState.jsx'\nimport TypeState from '../state/TypeState.js'\nimport ObjectType from '../../core/definitions/objectType'\n// import modules here\nimport CreateType from '../components/CreateType'\nimport EmptyPage from '../components/EmptyPage'\n\n@observer export default class Modules extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n\n  getModuleTypes() {\n    const moduleTypes = []\n    const types = TypeState.orderedUserMadeTypeList\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].data\n      moduleTypes.push(\n        <CreateType key={`construct-type-${type.id}`} type={type} />\n      )\n    }\n    return moduleTypes\n  }\n\n  render() {\n    const moduleTypes = this.getModuleTypes()\n    let child = null\n    if (moduleTypes.length > 0) {\n      child = moduleTypes\n    } else {\n      child = (<EmptyPage title=\"No Modules\" message=\"Press the + button in the bottom right to add a module\" />)\n    }\n    return (\n      <Page id=\"Modules\" title=\"Modules\">\n        {child}\n      </Page>\n    )\n  }\n}\n\nModules.propTypes = {\n  state: PropTypes.instanceOf(AppState),\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/modules.jsx"],"sourceRoot":""}